---
layout:     post
title:      领域事件(Event)驱动和监听
subtitle:   基于 Spring boot 框架实现事件驱动和监听
date:       2017-10-19
author:     uncledrew
header-img: img/post-bg-re-vs-ng2.jpg
catalog: true
tags:
    - Spring boot
    - Event
    - Publisher
    - Listener
    - 事件驱动
---

> 纸上得来终觉浅，绝知此事要躬行。
>
> [我的博客](http://uncledrewzhu.github.io/)

# 前言
现在流行的DDD(领域驱动设计)模型已经普遍用于项目中，一个产品根据不同的领域划分，进行开发，互相隔离却又互相合作。

当然，不同的领域之间有时候是需要通信的。假如存在A(登录)和B(记录用户日志)两个领域，需要实现用户登录后，打印用户名。有两种实现模式：
1. 在A领域的服务中嵌入B领域服务的代码逻辑。
2. A领域服务成功后，通过事件驱动，在监听器中实现B领域服务的逻辑。

模式二相比于模式一，大大降低了代码的耦合性。通过事件驱动和监听器，易于代码的维护和管理。


# 事件驱动的实现方式

### 基于 Spring boot 框架 集成 ApplicationEvent 实现事件驱动

事件源发布事件，一个事件可以被多个监听器同时监听。监听器分为有序和无序两种。

![](http://oxy6ml8al.bkt.clouddn.com/event-work-flow.png)

实现代码：

#### 定义登录bean
```
private String name;
private String password;
```

#### 定义登录事件
```
public class LoginEvent extends ApplicationEvent {

    public LoginEvent(LoginBean loginBean) {
        super(loginBean);
    }
}
```

#### 定义一个无序监听器
```
@Service
public class AfterLoginListenerNoOrder {

    @EventListener
    public void onLoginEvent(LoginEvent loginEvent) {
        LoginBean loginBean = (LoginBean) loginEvent.getSource();
        System.out.println("无序监听器，用户名 " + loginBean.getName());
    }

}
```

#### 定义三个有序监听器
```
@Service
public class AfterLoginListener1 implements SmartApplicationListener {

    @Override
    public boolean supportsEventType(final Class<? extends ApplicationEvent> eventType) {
        return eventType == LoginEvent.class;//定义监听的事件类型
    }

    @Override
    public boolean supportsSourceType(final Class<?> sourceType) {
        return sourceType == LoginBean.class;//定义监听的事件参数
    }

    @Override
    public void onApplicationEvent(ApplicationEvent applicationEvent) {
        LoginBean loginBean = (LoginBean) applicationEvent.getSource();
        System.out.println("有序监听器1，用户名 " + loginBean.getName());
    }

    @Override
    public int getOrder() {
        return 1;//排序号，越小越先执行
    }
}


@Service
public class AfterLoginListener2 implements SmartApplicationListener {

    ......

    @Override
    public void onApplicationEvent(ApplicationEvent applicationEvent) {
        LoginBean loginBean = (LoginBean) applicationEvent.getSource();
        System.out.println("有序监听器2，用户名 " + loginBean.getName());
    }

    @Override
    public int getOrder() {
        return 2;
    }
}


@Service
public class AfterLoginListener3 implements SmartApplicationListener {

    ......

    @Override
    public void onApplicationEvent(ApplicationEvent applicationEvent) {
        LoginBean loginBean = (LoginBean) applicationEvent.getSource();
        System.out.println("有序监听器3，用户名 " + loginBean.getName());
    }

    @Override
    public int getOrder() {
        return 3;
    }
}
```

#### 定义登录服务，在服务中发布事件
```
@Service
public class LoginService {

    @Autowired
    private ApplicationEventPublisher applicationEventPublisher;

    public void login(String name, String password) {
        System.out.println("用户名：" + name + ",密码：" + password + " 验证中！");
        try {
            applicationEventPublisher.publishEvent(new LoginEvent(new LoginBean(name, password)));
        } catch (Exception e) {
            System.out.println("监听器异常:" + e.getMessage());
        }
        System.out.println("用户名：" + name + ",密码：" + password + " 验证结束！");
    }
}
```

#### 定义Spring boot项目入口
```
@SpringBootApplication
public class Application implements CommandLineRunner {

    @Autowired
    LoginService service;

    @Override
    public void run(String... args) throws Exception {
        service.login("lfzhu", "123456");
    }

    public static void main(String[] args) throws Exception {
        SpringApplication.run(Application.class, args);
        System.exit(0);
    }
}
```

#### 运行结果
```
用户名：lfzhu,密码：123456 验证中！
无序监听器，用户名 lfzhu
有序监听器1，用户名 lfzhu
有序监听器2，用户名 lfzhu
有序监听器3，用户名 lfzhu
用户名：lfzhu,密码：123456 验证结束！
```



### 基于 Spring 的注解纯手工搭建一套事件工厂和事件监听框架


